# Mars_Lander_1.cpp

**Название пазла:** Mars Lander - Episode 1  
**Задача:** Совершить посадку марсохода

Это первый пазл из серии, рассматривается самая простая ситуация, где шаттл находится над зоной посадки, у него нет начальной скорости, и также он находится в вертикальном положении.
### Решение
Решение заключается в проверке на каждом цикле вертикальной скорости шаттла(v_speed <= -40). Если скорость превышает допустимую при посадке, то необходимо уменьшить скорость путем включения двигателя. В задании указано что сила тяжести на Марсе составляет 3,711 м/c2, поэтому чтобы уменьшить скорость надо выставить power в значение 4. Если скорость не превышает допустимую при посадке, то двигатель отключается.


# ASCII_Art.cpp

**Название пазла:** ASCII Art  
**Задача:** Отобразить строку текста в ASCII-графике в стиле, указанном в качестве входных данных.
На вход поступают три строки:
- ширина **L**
- высота **H**
- строка **T**, которая состоит из символов ASCII
Следующие строки: строка символов ABCDEFGHIJKLMNOPQRSTUVWXYZ? Представлена ​​в виде ASCII-арта.

### Решение
Создается строка, прееставляющая собой алфавит a-z плюс знак ?

Строки преддставленные в виде ASCII-арта считываются в вектор `representation`. Вектор будет состоять из **H** строк. Далее происходит итерация по строке **T**. На каждой итерации в алфавите ищется символ из **T**, если символ найден, то с помощью его индекса вычисляется начало подстроки, которая является частью репрезентации символа в ASCII. Найденная подстрока выводится на экран. Итерации по строке **T** происходят **H** раз.


# Unary.cpp

**Название пазла:** Unary  
**Задача:** Отобразить строку текста в виде кода, который состоит только из 0.
Вот принцип кодирования:
    - Входное сообщение состоит из символов ASCII (7 бит)
    - Закодированное выходное сообщение состоит из блоков по 0
    - Блок отделяется от другого блока пробелом.
    - Два последовательных блока используются для создания серии битов с одинаковыми значениями (только значения 1 или 0):
        - Первый блок: всегда 0 или 00. Если это 0, то ряд содержит 1, если нет, то он содержит 0.
        - Второй блок: количество нулей в этом блоке равно количеству бит в серии.

### Решение
Входная строка `message` преобразуется в последовательность двоичного кода и записывается в строку `bitMessage`. Далее происходит итерация по строке `bitMessage`. В процессе итерации ищутся подпоследовательности одинаковых подряд идущих символов, в конце каждой подпоследовательности в стандартный поток вывода передается код, согласно описанному выше принципу.


# There_is_no_Spoon_1.cpp

**Название пазла:** There is no Spoon - Episode 1  
**Задача:**  
Игра ведётся на прямоугольной сетке заданного размера. Некоторые ячейки содержат силовые узлы. Остальные ячейки пустые.  
Цель состоит в том, чтобы найти горизонтальных и вертикальных соседей каждого узла, если таковые имеются.  
  Правила

Для этого необходимо найти все координаты (x1,y1), содержащие узел, и отобразить координаты (x2,y2) следующего узла справа и координаты (x3,y3) следующего узла снизу в сетке.  
Если соседа не существует, необходимо вывести координаты -1 -1 вместо (x2,y2) и/или (x3,y3).  
Вы проиграете, если:  
    Вы указали неверного соседа для узла.  
    Вы отдаете соседям за пустую ячейку.  
    Вы вычисляете один и тот же узел дважды.  
    Вы забываете вычислить соседей узла.  

### Решение
Изначально в вектор `grid` записывается состояние игрового поля. Далее идет итерация слева направо, сверху вниз по игровому полю, если нашлась нода, то для нее ищется ближайшая нода справа и снизу, если какой-то ноды нет, то в итоговом ответе вместо этих координат записывается "-1 -1".


# MIME_types.cpp  

**Название пазла:** MIME Type  
**Задача:**  
Вам предоставляется таблица, связывающая типы MIME с расширениями файлов. Вам также предоставляется список имён файлов для передачи, и для каждого из них необходимо указать тип MIME, который будет использоваться.  
Расширение файла определяется как подстрока, которая следует за последним вхождением символа точки (если таковое имеется) в имени файла.  
Если расширение для заданного файла найдено в таблице ассоциаций (без учёта регистра, например, TXT обрабатывается так же, как txt), вывести соответствующий MIME-тип. Если MIME-тип, соответствующий файлу, найти не удаётся или у файла нет расширения, вывести UNKNOWN.
  
### Решение  
Для хранения таблицы ассоциаций используюется хэш-таблица, так как каждый отдельный поиск элемента в ней занимает в среднем O(1). В каждом поступившем имени файла ищется последний символ точки, чтобы определить расширение файла. Расширение файла ищется в хэш-таблице и сопоставляется с MIME типом. Важно отметить что расширение не учитывает регистр, и поэтому расширения в хэш-таблице и полученные из имени файла, преобразуются в нижний регистр.


# Horse-racing_Duals.cpp  

**Название пазла:** Horse-racing Duals    
**Задача:**  
Ипподром Касабланки организует новый вид скачек: парные. В парных скачках участвуют только две лошади. Чтобы скачки были интересными, необходимо выбрать двух лошадей примерно одинаковой силы.  
Напишите программу, которая, используя заданное количество значений силы, определяет две наиболее близкие значения силы и показывает их разницу целым числом (≥ 0).

### Решение  
Входные данные сохраняются в вектор. Полученный вектор сортируется. Далее итерируемся по отсортированному вектору и ищем минимальную разницу между соседними элементами. Полученны минимум является ответом.  

  
  
# Six_degrees.cpp  

**Название пазла:** Six Degrees of Kevin Bacon  
    
**Задача:**  
«Шесть степеней Кевина Бэйкона» — это игра о поп-культуре, в которой произвольно выбранный актер неоднократно связывается с другим актером через фильм, в котором оба актера появлялись вместе, повторяя этот процесс, чтобы попытаться найти кратчайший путь, который в конечном итоге приведет к плодовитому американскому актеру Кевину Бэйкону.  

Учитывая actor_name, целое число n и указанное количество movie_casts, определяем число Бэкона для actor_name, т.е. минимальное количество фильмов, необходимое для связи actor_name с Кевином Бэконом.  

### Решение  
Входные данные преобразуются в список смежности, который хранит граф связывающий актеров если они снимались в одном фильме. Далее используется поиск в ширину для того чтобы найти кратчайший путь от нужного актера до Кевина Бэйкона.  


  
    
# Death_First_Search_1.cpp  

**Название пазла:** Death First Search - Episode 1  
    
**Задача:**  
Ваш вирус открыл бэкдор в сети Bobnet, что позволяет вам отправлять новые инструкции в режиме реального времени.  
Вы решаете принять меры и прекратить общение Bobnet в его внутренней сети.  
Сеть Bobnet разделена на несколько более мелких сетей, в каждой подсети есть агент Bobnet, задача которого — передавать информацию, перемещаясь от узла к узлу по связям и получая доступ к шлюзам, ведущим к другим подсетям.  
Ваша задача — перепрограммировать вирус таким образом, чтобы он разрывал связи таким образом, что агент Bobnet не сможет получить доступ к другой подсети, тем самым не давая информации о присутствии нашего вируса достичь центрального узла Bobnet.
  
**Инициализация**  
Строка 1: 3 целых числа N,L,E
- N, общее количество узлов на уровне, включая шлюзы.
- L, количество связей на уровне.
- E — количество выходов на уровне.  

Следующие L строк: 2 целых числа в каждой строке (N1, N2), обозначающие связь между узлами с индексами N1 и N2 в сети.  
Следующие строки E: 1 целое число EI, представляющее индекс узла шлюза.
**Вход для одного игрового хода**  
Строка 1: 1 целое число SI, которое является индексом узла, на котором в этом ходу находится агент Bobnet.
**Выход за один игровой ход**  
Одна строка, состоящая из двух целых чисел C1 и C2, разделенных пробелом. C1 и C2 — индексы узлов, между которыми требуется разорвать связь.  

### Решение  
Входные данные преобразуются в матрицу смежности, которая хранит граф связывающий узлы. Далее каждый игровой ход используется обход в ширину для того чтобы найти кратчайшие пути от агента до каждого узла. После обхода в ширину будет получен список узлов с длиной пути, из этого списка выбирается узел с наименьшей дистацией, который является выходом из подсети. Если путь от агента до выбранного узла больше чем одна связь, то разрывается ближайшая к агенту связь.  



# Shadows_Night_1.cpp  

**Название пазла:** Shadows of the Knight - Episode 1  
    
**Задача:**  
Вам предстоит искать заложников в заданном здании, перепрыгивая из окна в окно с помощью крюка-кошки. Ваша цель — допрыгнуть до окна, где находятся заложники, чтобы обезвредить бомбы. К сожалению, количество прыжков ограничено, прежде чем бомбы взорвутся...  

Перед каждым прыжком устройство теплового сигнатурирования будет показывать направление падения бомб на основе вашего текущего местоположения: U(вверх),  UR(вверх-вправо), R(справа), DR(вниз-вправо), D(вниз), DL(вниз-влево), Л(слева), UL(вверх-влево).  

Ваша задача — запрограммировать устройство так, чтобы оно указывало местоположение следующего окна, в которое вам следует прыгнуть, чтобы как можно скорее добраться до комнаты с бомбами.  

Здания представлены в виде прямоугольного массива окон, окно в верхнем левом углу здания имеет индекс (0,0).  
  
### Решение  
Основная идея состоит в том, чтобы использовать бинарный поиск. Например, если на вход поступило направление U(вверх), то надо прыгнуть в такое окно, которое будет являться серединой вышележащих окон. И аналогично для других направлений. Таким образом мы сужаем область поиска и в конечном итоге прыгаем в нужное окно.  


# Shadows_Night_2.cpp  

**Название пазла:** Shadows of the Knight - Episode 2  
    
**Задача:**  
Вам предстоит искать заложников в заданном здании, перепрыгивая из окна в окно с помощью крюка-кошки. Ваша цель — допрыгнуть до окна, где находятся заложники, чтобы обезвредить бомбы. К сожалению, количество прыжков ограничено, прежде чем бомбы взорвутся...   

После каждого прыжка обновленное устройство теперь будет предоставлять вам следующий информационный код:  
- ХОЛОДНЕЕ Вы находитесь дальше от бомб, чем были до прыжка.  
- ТЕПЛЕЕ Вы ближе к бомбам, чем были до прыжка  
- ТО ЖЕ САМОЕ Вы находитесь на том же расстоянии от бомб, что и до прыжка.  
- НЕИЗВЕСТНО Устройство не может предоставить вам никакой информации: происходит только перед первым прыжком.  
  
Что касается предыдущего вопроса, ваша задача — запрограммировать устройство так, чтобы оно указывало местоположение следующего окна, в которое вам следует прыгнуть, чтобы как можно скорее добраться до комнаты с бомбами.  

Здания представлены в виде прямоугольного массива окон, окно в верхнем левом углу здания имеет индекс (0,0).  
  
### Решение  
Координаты бомбы ищутся последовательно, сначала находится координата X, затем ищется координата Y. Каждая координата ищется с использованием алгоритма похожего на бинарный поиск. В зависимости от обратной связи границы поиска сужаются:  

- WARMER: цель находится на той же стороне от середины, что и текущая точка  
- COLDER: цель находится на противоположной стороне от середины  


# Dont_Panic_1.cpp  

**Название пазла:** Don't Panic - Episode 1  
 
    
**Задача:**  
Диск имеет прямоугольную форму переменного размера. Он состоит из нескольких этажей (0 = нижний этаж), и на каждом этаже есть несколько возможных позиций, которые могут занимать клоны (0 = крайнее левое положение, ширина - 1 = крайнее правое положение).  
Цель — спасти хотя бы одного клона за ограниченное количество раундов.  
Подробности:  
- Клоны появляются из уникального генератора с регулярными интервалами, каждые три хода игры. Генератор расположен на нулевом этаже. Клоны выходят из генератора, направляясь вправо.  
- Клоны перемещаются на одну позицию за ход по прямой, двигаясь в своем текущем направлении.  
- Клон уничтожается лазером, если он оказывается за позицией 0 или за пределами width - 1.  
- Лифты разбросаны по всему подъезду и позволяют перемещаться с этажа на этаж выше. Когда клон прибывает на место расположения лифта, он поднимается на этаж выше. Подъем на этаж выше занимает один игровой ход. На следующем ходу клон продолжает движение в том же направлении, в котором он двигался до этого.  
- На каждом ходу игры вы можете либо заблокировать лидирующего клона (то есть того, который вышел раньше всех), либо не делать ничего.  
- После блокировки клона вы больше не сможете его использовать. Следующий клон в очереди становится «ведущим» и может быть заблокирован позднее.  
- Когда клон движется к заблокированному клону, он меняет направление движения слева направо или справа налево. Он также меняет направление движения, когда выходит из генератора непосредственно на заблокированном клоне или поднимается на лифте на заблокированный клон.  
- Если клон заблокирован перед лифтом, лифтом больше нельзя будет пользоваться.  
- Когда клон достигает места выхода, он сохраняется и исчезает из зоны.  
Примечание: в этой головоломке на каждом этаже имеется не более одного лифта.  
  
### Решение  
Решение состоит в том, чтобы проверять направление движения клона. Если он движется в противоположном направлении от лифта, на данном этаже, или от выхода, то он блокируется. Таким образом клоны двигаются по оптимальному маршруту.


# War.cpp  

**Название пазла:** War  
 
    
**Задача:**  
Война — карточная игра между двумя игроками. В начале игры каждый игрок получает определённое количество карт: это его колода. Карты кладутся рубашкой вверх поверх каждой колоды.  
На вход подаются колоды каждого игрока.  
Программа должна вывести, кто победит и количество раундов. Или если произошла ничья, то выводится значение "PAT".
  
### Решение  
Колода каждого игрока хранится в очереди. Далее в цикле с условием, что обе очереди не пустые, воспроизводится сама игра, т.е. выбираются первые карты из каждой очереди и сравниваются, карты помещаются в очередь из которой вышла старшая карта. Таким образом, когда цикл закончится, одна очередь останется пуста, отсюда и получаем победителя.